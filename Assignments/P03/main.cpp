#include <iostream>
#include "JsonFacade.hpp"
#include <time.h>
#include <chrono>
#include "Timer.hpp"
#include "mygetch.hpp"
#include "termcolor.hpp"

using namespace std;

// Define the character size
#define CHAR_SIZE 128

// A class to store a Trie node
class Trie
{
public:
    bool isLeaf;
    char value;
    Trie *character[CHAR_SIZE];

    // Constructor
    Trie()
    {
        this->isLeaf = false;

        for (int i = 0; i < CHAR_SIZE; i++)
        {
            this->character[i] = nullptr;
        }
    }

    void insert(string);
    bool deletion(Trie *&, string);
    bool search(string);
    bool haveChildren(Trie const *);
    vector<string> autoSuggest(string);
};

// Iterative function to insert a key into a Trie
void Trie::insert(string key)
{
    // start from the root node
    Trie *curr = this;
    for (int i = 0; i < key.length(); i++)
    {
        // create a new node if the path doesn't exist
        if (curr->character[key[i]] == nullptr)
        {
            curr->character[key[i]] = new Trie();
            curr->character[key[i]]->value = key[i];
        }

        // go to the next node
        curr = curr->character[key[i]];
    }

    // mark the current node as a leaf
    curr->isLeaf = true;
}

// Iterative function to search a key in a Trie. It returns true
// if the key is found in the Trie; otherwise, it returns false
bool Trie::search(string key)
{
    // return false if Trie is empty
    if (this == nullptr)
    {
        return false;
    }

    Trie *curr = this;
    for (int i = 0; i < key.length(); i++)
    {
        // go to the next node
        curr = curr->character[key[i]];

        // if the string is invalid (reached end of a path in the Trie)
        if (curr == nullptr)
        {
            return false;
        }
    }

    // return true if the current node is a leaf and the
    // end of the string is reached
    return curr->isLeaf;
}

// A function that traverses the trie and returns all words starting
// with given query
vector<string> Trie::autoSuggest(string query)
{
    // holder for suggesstions generated by trie
    vector<string> result;
    Trie *curr = this;
    // check if given query is present in trie or not
    // if query is not present return empty vector as result
    // otherwise move to Trie node pointing to last character of query
    for (int i = 0; i < query.length(); i++)
    {
        curr = curr->character[query[i]];
        if (curr == nullptr)
        {
            return result;
        }
    }
    // if query is a proper word in dictionary, add it to suggestions
    if (curr->isLeaf)
    {
        result.push_back(query);
    }
    // go throught all possible characters that can be present at the end of query
    for (int i = 0; i < CHAR_SIZE; i++)
    {
        // check whether ascii character represented by i is present in trie node 
        if (curr->character[i] != nullptr)
        {
            // recursively find all possible words that can be generated from current node
            vector<string> temp = curr->character[i]->autoSuggest("");

            // add query and current character as prefix to all results to form proper words
            string prefix = query + (char)i;
            for (int j = 0; j < temp.size(); j++)
            {
                temp[j] = prefix + temp[j];
            }

            // add suggestions generated by recursive call to suggestions store in result vector
            result.insert(result.end(), temp.begin(), temp.end());
        }
    }
    return result;
}

// Returns true if a given node has any children
bool Trie::haveChildren(Trie const *curr)
{
    for (int i = 0; i < CHAR_SIZE; i++)
    {
        if (curr->character[i])
        {
            return true; // child found
        }
    }

    return false;
}

// Recursive function to delete a key in the Trie
bool Trie::deletion(Trie *&curr, string key)
{
    // return if Trie is empty
    if (curr == nullptr)
    {
        return false;
    }

    // if the end of the key is not reached
    if (key.length())
    {
        // recur for the node corresponding to the next character in the key
        // and if it returns true, delete the current node (if it is non-leaf)

        if (curr != nullptr &&
            curr->character[key[0]] != nullptr &&
            deletion(curr->character[key[0]], key.substr(1)) &&
            curr->isLeaf == false)
        {
            if (!haveChildren(curr))
            {
                delete curr;
                curr = nullptr;
                return true;
            }
            else
            {
                return false;
            }
        }
    }

    // if the end of the key is reached
    if (key.length() == 0 && curr->isLeaf)
    {
        // if the current node is a leaf node and doesn't have any children
        if (!haveChildren(curr))
        {
            // delete the current node
            delete curr;
            curr = nullptr;

            // delete the non-leaf parent nodes
            return true;
        }

        // if the current node is a leaf node and has children
        else
        {
            // mark the current node as a non-leaf node (DON'T DELETE IT)
            curr->isLeaf = false;

            // don't delete its parent nodes
            return false;
        }
    }

    return false;
}

int main()
{
    char k;                 // holder for character being typed
    string word = "";       // var to concatenate letters to
    vector<string> words;   // array of words
    vector<string> matches; // any matches found in vector of words
    int loc;                // location of substring to change its color
    Timer T;                // create a timer

    ofstream fout("temp.txt");

    // load data from json file into trie and get keys from json file
    JsonFacade J("dicts_w_defs.json"); // create instance of json class
    words = J.getKeys();

    // load data in trie
    Trie *dict = new Trie();
    for (string dictWord : words)
    {
        dict->insert(dictWord);
    }

    cout << "Start typing to see autosuggestions.\n\n"
         << endl;
    // While capital Z is not typed keep looping
    while ((k = getch()) != 'Z')
    {
        T.Start(); // start timer as soon as user enters a character
        // Tests for a backspace and if pressed deletes
        // last letter from "word".
        if ((int)k == 127)
        {
            if (word.size() > 0)
            {
                word = word.substr(0, word.size() - 1);
            }
        }
        else
        {
            // Make sure a letter was pressed and only letter
            if (!isalpha(k))
            {
                cout << "Letters only!" << endl;
                continue;
            }

            // We know its a letter, lets make sure its lowercase.
            // Any letter with ascii value < 97 is capital so we
            // lower it.
            if ((int)k < 97)
            {
                k += 32;
            }
            word += k; // append char to word
        }

        // if k is not a space or word is not empty string print suggestions
        if ((int)k != 32 && word != "")
        {
            // get suggesstion from trie and stop timer
            matches = dict->autoSuggest(word);
            T.End();
            cout << termcolor::red << word << termcolor::reset << endl
                 << endl;
            cout << termcolor::blue;

            cout << matches.size() << " words found in " << T.Seconds() << " seconds" << endl
                 << endl;
            // This prints out all found matches
            for (int i = 0; i < matches.size() && i < 10; i++)
            {
                // find the substring in the word
                loc = matches[i].find(word);
                // if its found
                if (loc != string::npos)
                {
                    // print one letter at a time turning on red or green
                    //  depending on if the matching subtring is being printed
                    for (int j = 0; j < matches[i].size(); j++)
                    {
                        // if we are printing the substring turn it red
                        if (j >= loc && j <= loc + word.size() - 1)
                        {
                            cout << termcolor::red;
                        }
                        else
                        {
                            cout << termcolor::green;
                        }
                        cout << matches[i][j];
                    }
                    cout << termcolor::green;
                }
                cout << " ";
            }
            cout << termcolor::reset << endl
                 << endl
                 << endl;
        }
    }

    return 0;
}